#ifndef HAREMAP_H
#define HAREMAP_H

// Map size
#define MAP_X 200
#define MAP_Y 200
// obstacles are entered in increments of 0.5
// here, in the descrete map of size MAX_X, each grid point represents 0.25
// so, every 4 cells in this map are really 1 cell
#define ODOM_TO_MAP 4.0
#define MAP_TO_ODOM 0.25


#include "utility.h"
#include "common_includes.h"

namespace hare{
  typedef struct map_node{
    int terrain;
    bool explored;
    bool traversable;
    int4 walls;
    bool path_helper;
  } map_node;
  //walls.x = left, walls.y = up, walls.z = down, walls.w = right
  typedef struct pq_node{
    int x;
    int y;
    float h; // heuristic priority
  } pq_node;

  //full map generated in a rediculous way with a python file
  //currently in HareMap.cpp
  extern map_node fullMap[MAP_X][MAP_Y];

  int2 odomToMap(float2 odomCoord);
  int2 odomToMap(float x, float y);
  float2 mapToOdom(int2 mapCoord);
  float2 mapToOdom(int x, int y);
}

#endif /* HAREMAP_H */

/*
SINCE HareMap.cpp is autogenerated, a copy of
the methods implemented there are provided here
*/
/*
int2 hare::odomToMap(float2 odomCoord){
    return {(int)(odomCoord.x*ODOM_TO_MAP + ((float)MAP_X)/2),(int)(odomCoord.y*ODOM_TO_MAP + ((float)MAP_Y)/2)};
}
int2 hare::odomToMap(float x, float y){
    return {(int)(x*ODOM_TO_MAP + ((float)MAP_X)/2),(int)(y*ODOM_TO_MAP + ((float)MAP_Y)/2)};
}
float2 hare::mapToOdom(int2 mapCoord){
  return {((float)mapCoord.x)*MAP_TO_ODOM - (((float)MAP_X)/2),((float)mapCoord.y)*MAP_TO_ODOM - (((float)MAP_Y)/2)};
}
float2 hare::mapToOdom(int x, int y){
  return {((float)x)*MAP_TO_ODOM - (((float)MAP_X)/2),((float)y)*MAP_TO_ODOM - (((float)MAP_Y)/2)};
}
*/
