<<<<<<< HEAD
=======
\subsection{Approach}
roll assignment with algorithms


>>>>>>> 1bb19a97940e366f61c849c7f49a0ff26f88a49f
\subsection{Role Assignment}
As aforementioned role assignment was predefined for the robot set. In the project three robots were given static characteristics, these characteristics were defined based on robot attributes. The simplified set of attributes taken into consideration were maneuverability and robot height. These attributes corresponded to terrain traversability, the terrain was indexed as follows: 0 - open terrain, 1 - ramp, 2 - short tunnels, and 3 - tall tunnels. Given the set of robots and attributes capabilities were defined. Robot 1 (Youbot) could traverse terrain 0, 2, and 3. Robot 2 (Rosbot) could traverse terrain 0, 1, and 3. Robot 3 (Husky) could traverse terrain all terrains in the terrain set, the robots and terrain is illustrated in figure \ref{fig:map}.


\begin{figure}
    \centering
    \begin{subfigure}[b]{0.15\textwidth}
        \includegraphics[width=\textwidth]{bot1}
        \caption{Husky}
        \label{fig:bot1}
    \end{subfigure}
    \begin{subfigure}[b]{0.15\textwidth}
        \includegraphics[width=\textwidth]{bot2}
        \caption{Rosbot}
        \label{fig:bot2}
    \end{subfigure}
    \begin{subfigure}[b]{0.15\textwidth}
        \includegraphics[width=\textwidth]{bot3}
        \caption{Youbot}
        \label{fig:bot3}
    \end{subfigure}
    \caption{Three commonly used robots with very different shapes and sizes.}\label{fig:bots}
\end{figure}

As an individual working in a cooperative operation, knowing the capabilities
of you and your teammates is necessary to the division of tasks. This idea
provides the basis for this proposed research. As homogeneous multi-robot systems
are inherently limited based on the capabilities of the specific robot,
it makes sense to venture down a heterogeneous avenue. A lot of research
has gone into heterogeneous multi-robot systems in the past few years, but a
common trend amongst most of them is that the model is built for the specific
platforms that are to be used. This proposed research is meant to provide the
groundwork for a heterogeneous model that allows for the insertion of a
robots with different skill sets with the purpose of enhancing the overall
capability of the system. This framework would allow for a variety of models
to be built on top of it, with a variety of hardware. Researchers wanting to
build a specific system could allocate funds and resources to build each member
to accomplish a portion of the overall task, possibly allowing for more cost
efficiency and remove unnecessary redundancy. The main challenge in this
research will be finding the optimal way to reassign tasks based on defined
capabilities of each robot in the system. This brings up a secondary, more basic,
challenge of defining robotâ€™s characteristics in a simple yet comprehensive manor.
All-in-all, this research acts as a proof of concept for task division based on member
attributes, or individual robots capabilities, and will allow for a high degree of
heterogeneous utilization and multi-robot model expansion.

\begin{figure}[H]
  \centering
    \includegraphics[width=0.5\textwidth]{map2}
  \caption{Gazebo map, with different terrain. Open terrain in gray, short tunnels in red and green, tall tunnels in blue.}
  \label{fig:map}
\end{figure}

\begin{figure}[H]
  \centering
    \includegraphics[width=0.5\textwidth]{map1}
  \caption{Robots in gazebo stage showin terrain set.}
  \label{fig:stage}
\end{figure}

\subsection{Algorithms}
<<<<<<< HEAD
For navigation we used two methods. The first is a Breadth First Search (BFS) which explores the cells adjacent to the robots
current positions, before exploring the second level of adjacent cells. After determinining explorable cells method getPath as described in Algorithm 1 will compute the a hueristic based on the manhattan distance to determine a set of cells that make up an optimal path. For robot exploration getPath can be called for exploration by simpling passing in a goal represented as the nearest unexplored node a summary of the path planning algorithm can be called with the goal being the nearest global unexplored node as shown in Algorithm \ref{fig:a-star}.
 The use cases for this method are as follows: a) robot needs to swap locations, b) robot finds an obstacle it cannot explore and needs another robot to explore it 3) the robot's tree-state is such that exploration needs to take place.

 \begin{figure}[H]
   \centering
     \includegraphics[width=0.5\textwidth]{a-star}
   \caption{An overview of the A* Algorithm \cite{a-star}} \label{fig:a-star}
 \end{figure}



=======
For navigation we used two methods. The first is a Breadth First Search as shown in algorithm \ref{BFS}(BFS) which explores the cells adjacent to the robots
current positions, before exploring the second level of adjacent cells. After determinining explorable cells method getPath as described in Algorithm 1 will compute the a hueristic based on the manhattan distance to determine a set of cells that make up an optimal path. For robot exploration getPath can be called with the goal being the nearest global unexplored node \cite{pound}.


% \begin{algorithm}[H]
% \caption{Breath First Search} \label{BFS}
% \begin{algorithmic}[1]
% \Procedure{getPath}{$start,goal$}
%     \State $knownap[i][j].initializeToZero()$
%     \State $q \leftarrow initializeQueue()$
%     \State $q_{n} \leftarrow initializeQueue(init_x, init_y, 0)$
%     \While{$q != empty$}
%         \State $loc = \{ curr.x, curr.y \}$
%         \If{$(loc = goal)$}
%           \State $break$ \Comment{reached goal}
%         \EndIf
%           \State $h_{map}[curr.x, curr.y] = curr.h$ \Comment{store element before popping}
%           \State $q.pop()$ \Comment{pop last element}
%         \If{$isInBounds(loc+step)$}  \Comment{check you are in map bounds}
%           \State $test \leftarrow loc + step$
%           \If{$isValid(test) \& cellEmpty()$}  \Comment{check cell unexplored and in bounds}
%             \State $adj \leftarrow {loc + step, h + 1}$ \Comment{update hueristic}
%             \State $q.push(adj)$ \Comment{add to queue}
%             \label{path}
%           \EndIf
%         \EndIf
%     \EndWhile
%     \State $temp \leftarrow orderedQ(q)$ \Comment{order elements based on hueristic}
%     \State $return \leftarrow temp$ \Comment{order elements based on hueristic}
% \EndProcedure
%
% \end{algorithmic}
% \end{algorithm}
>>>>>>> 1bb19a97940e366f61c849c7f49a0ff26f88a49f

% this section has 3 figures together

\subsection{Multi-Agent Testing Framework}

After exploring a set of options to test this idea, the best place to go was to the drawing
board. Taking a step back it was decided that pushing to get straight into hardware testing
was a poor decision and the underlying concept of heterogeneous task reallocation based on
capabilities needed to be tested at the lowest of levels. To do this, the creation of a testing
framework in roscpp was necessary. This framework allows for easy addition of robots by simply
adding the details for the new robot in the xml robots launch file. To add any additional information
yaml files can be used to set rosparams, just as was done here for robot capabilties. By configuring
the launch file with the proper robots, one can edit the one robot launch file to have each robot launch
any set of nodes that would exist in each robot's namespace. This allows for testing of a completely
decentralized algorithm in a centralized system. The reason this was done was because of the difficulty
of getting a multimaster architecture working within gazebo.
